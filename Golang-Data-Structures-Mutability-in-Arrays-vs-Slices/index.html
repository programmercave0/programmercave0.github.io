<!DOCTYPE html>
<html lang="en">
<head>
  
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-LGYYYX4F59"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-LGYYYX4F59');
  </script>

  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6819793054373827"
     crossorigin="anonymous"></script>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="generator" content="Hugo 0.123.7">
  
  
      
  
  
  
  <meta name="description" content="Introduction Both arrays and slices in Go allow you to change their elements after creation—this is what we mean by “mutability.” But how changes affect other parts of your code differs a lot between the two. This note builds on the basics of arrays and slices by focusing on mutability in practice, including how to control it safely in larger programs. We’ll cover advanced tips useful for experienced developers, like handling shared changes in concurrent code or designing functions that avoid surprises.">
  <meta name="keywords" content="Go, programming, language,, Golang, speed,, compiled, languages,, concurrency, in, Go,, goroutines,, Go, garbage, collection,, high-performance, applications,, Go, interview, preparation,, native, compilation,, modern, hardware, optimization,, fast, compile, times,, efficient, coding, practices,, Golang, features">
  <link rel="stylesheet" href="https://programmercave.com/css/normalize.css">
  <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
  
  
  
  <link rel="stylesheet" href="https://programmercave.com/css/cayman.ea0e967413f3851071cc8ace3621bc4205fe8fa79b2abe3d7bf94ff2841f0d47.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
  
  
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.js" integrity="sha384-9Nhn55MVVN0/4OFx7EE5kpFBPsEMZxKTCnA+4fqDmg12eCTqGi6+BB2LjY8brQxJ" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>

  <title>Golang - Data Structures - Mutability in Arrays vs. Slices | programmerCave</title>
</head>

<body>
  <section class="page-header">
  <h1 class="project-name">
    programmerCave
  </h1>
  <nav>
    
    
      
      
      
      <a href="/" class="btn">Home</a>
    
      
      
      
      <a href="/tags/" class="btn">Tags</a>
    
      
      
      
      <a href="/index.xml" class="btn">RSS</a>
    
  </nav>
</section>

  <section class="main-content">
    
  <h1>Golang - Data Structures - Mutability in Arrays vs. Slices</h1>
  <div>
    
    <strong>Publish date: </strong>2025-09-10
  </div>
  
  
    <div>
      <strong>Tags: </strong>
      
        
        
        
      
      &lt;a href=&#34;https://programmercave.com/tags/Go/&#34;&gt;Go&lt;/a&gt;
    </div>
  
  <h3 id="introduction">Introduction</h3>
<p>Both arrays and slices in Go allow you to change their elements after creation—this is what we mean by &ldquo;mutability.&rdquo; But how changes affect other parts of your code differs a lot between the two. This note builds on the basics of arrays and slices by focusing on mutability in practice, including how to control it safely in larger programs. We&rsquo;ll cover advanced tips useful for experienced developers, like handling shared changes in concurrent code or designing functions that avoid surprises.</p>
<hr>
<h3 id="the-core-of-mutability-changes-and-sharing">The Core of Mutability: Changes and Sharing</h3>
<ul>
<li><strong>Mutability basics:</strong> You can always update elements in both arrays and slices using index assignment (like <code>a = newValue</code>). The big difference is in how those changes &ldquo;spread&rdquo; when you have multiple variables or functions involved.</li>
<li><strong>Array mutability:</strong> Changes are isolated because arrays copy everything. This makes them safe but can be slow for big data.</li>
<li><strong>Slice mutability:</strong> Changes are often shared because slices point to the same hidden storage. This is efficient but can lead to unexpected updates if not managed.</li>
</ul>
<p><strong>Analogy:</strong> Updating an array is like editing a personal notebook—your changes stay in your copy. Updating a slice is like editing a shared document—everyone with access sees the changes instantly, unless someone makes a private copy.</p>
<hr>
<h3 id="controlling-slice-mutability-with-capacity-limits">Controlling Slice Mutability with Capacity Limits</h3>
<p>Slices can share storage, but you can limit this sharing by controlling how much room a slice has to grow without creating new storage.</p>
<ul>
<li><strong>Full slice expression:</strong> Use <code>s[low:high:max]</code> to set a custom limit on growth space (capacity = max - low). This forces any growth to create fresh storage, preventing unwanted shared changes.</li>
<li><strong>Why it helps mutability:</strong> It stops one slice from accidentally overwriting another&rsquo;s data during growth.</li>
</ul>
<h4 id="code-example-limiting-shared-changes">Code Example: Limiting Shared Changes</h4>
<div class="highlight"><pre tabindex="0" style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#008000;font-weight:bold">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000;font-weight:bold">import</span> <span style="color:#ba2121">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000;font-weight:bold">func</span> <span style="color:#00f">main</span>() {
</span></span><span style="display:flex;"><span>    parent <span style="color:#666">:=</span> []<span style="color:#b00040">int</span>{<span style="color:#666">10</span>, <span style="color:#666">20</span>, <span style="color:#666">30</span>, <span style="color:#666">40</span>, <span style="color:#666">50</span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#408080;font-style:italic">// Unlimited growth space: shares with parent
</span></span></span><span style="display:flex;"><span><span style="color:#408080;font-style:italic"></span>    unlimited <span style="color:#666">:=</span> parent[<span style="color:#666">1</span>:<span style="color:#666">3</span>] <span style="color:#408080;font-style:italic">// [20 30], can grow into parent&#39;s space
</span></span></span><span style="display:flex;"><span><span style="color:#408080;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#408080;font-style:italic">// Limited growth space: forces new storage on growth
</span></span></span><span style="display:flex;"><span><span style="color:#408080;font-style:italic"></span>    limited <span style="color:#666">:=</span> parent[<span style="color:#666">1</span>:<span style="color:#666">3</span>:<span style="color:#666">3</span>] <span style="color:#408080;font-style:italic">// [20 30], max=3 so capacity=2 (can&#39;t grow without new storage)
</span></span></span><span style="display:flex;"><span><span style="color:#408080;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    unlimited = <span style="color:#008000">append</span>(unlimited, <span style="color:#666">99</span>) <span style="color:#408080;font-style:italic">// Might change parent
</span></span></span><span style="display:flex;"><span><span style="color:#408080;font-style:italic"></span>    limited = <span style="color:#008000">append</span>(limited, <span style="color:#666">99</span>)     <span style="color:#408080;font-style:italic">// Always creates new storage, safe from changing parent
</span></span></span><span style="display:flex;"><span><span style="color:#408080;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    fmt.<span style="color:#00f">Println</span>(<span style="color:#ba2121">&#34;Parent after unlimited append:&#34;</span>, parent) <span style="color:#408080;font-style:italic">// Could be changed
</span></span></span><span style="display:flex;"><span><span style="color:#408080;font-style:italic"></span>    fmt.<span style="color:#00f">Println</span>(<span style="color:#ba2121">&#34;Parent after limited append:&#34;</span>, parent)   <span style="color:#408080;font-style:italic">// Unchanged
</span></span></span><span style="display:flex;"><span><span style="color:#408080;font-style:italic"></span>}
</span></span></code></pre></div><p><strong>Output (may vary, but shows the idea):</strong></p>
<pre tabindex="0"><code>Parent after unlimited append: [10 20 30 99 50] // Shared change happened
Parent after limited append: [10 20 30 99 50]   // No further change
</code></pre><p>This technique is great for handing out &ldquo;read-only views&rdquo; that can&rsquo;t accidentally mutate the original through growth.</p>
<hr>
<h3 id="safe-copying-to-break-mutability-sharing">Safe Copying to Break Mutability Sharing</h3>
<p>To make sure changes don&rsquo;t affect the original, create a full copy with its own storage.</p>
<ul>
<li><strong>Using slices.Clone (Go 1.21+):</strong> This built-in function makes a new slice with copied elements and independent storage. It&rsquo;s clearer than older tricks.</li>
<li><strong>Why for mutability:</strong> It gives you a &ldquo;private&rdquo; version where changes stay isolated, like making a photocopy before marking it up.</li>
</ul>
<h4 id="code-example-cloning-for-independent-changes">Code Example: Cloning for Independent Changes</h4>
<div class="highlight"><pre tabindex="0" style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#008000;font-weight:bold">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000;font-weight:bold">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#ba2121">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ba2121">&#34;slices&#34;</span> <span style="color:#408080;font-style:italic">// Need this for slices.Clone
</span></span></span><span style="display:flex;"><span><span style="color:#408080;font-style:italic"></span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000;font-weight:bold">func</span> <span style="color:#00f">main</span>() {
</span></span><span style="display:flex;"><span>    original <span style="color:#666">:=</span> []<span style="color:#b00040">string</span>{<span style="color:#ba2121">&#34;apple&#34;</span>, <span style="color:#ba2121">&#34;banana&#34;</span>, <span style="color:#ba2121">&#34;cherry&#34;</span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    cloned <span style="color:#666">:=</span> slices.<span style="color:#00f">Clone</span>(original) <span style="color:#408080;font-style:italic">// New storage, safe to change
</span></span></span><span style="display:flex;"><span><span style="color:#408080;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    cloned[<span style="color:#666">0</span>] = <span style="color:#ba2121">&#34;avocado&#34;</span> <span style="color:#408080;font-style:italic">// Only affects cloned
</span></span></span><span style="display:flex;"><span><span style="color:#408080;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    fmt.<span style="color:#00f">Println</span>(<span style="color:#ba2121">&#34;Original:&#34;</span>, original) <span style="color:#408080;font-style:italic">// Unchanged
</span></span></span><span style="display:flex;"><span><span style="color:#408080;font-style:italic"></span>    fmt.<span style="color:#00f">Println</span>(<span style="color:#ba2121">&#34;Cloned:&#34;</span>, cloned)     <span style="color:#408080;font-style:italic">// Updated
</span></span></span><span style="display:flex;"><span><span style="color:#408080;font-style:italic"></span>}
</span></span></code></pre></div><p><strong>Output:</strong></p>
<pre tabindex="0"><code>Original: [apple banana cherry]
Cloned: [avocado banana cherry]
</code></pre><p>For older Go versions, use <code>append([]T(nil), original...)</code> instead—it&rsquo;s the same idea but less readable.</p>
<hr>
<h3 id="mutability-in-concurrent-code">Mutability in Concurrent Code</h3>
<p>When multiple parts of your program run at the same time (using goroutines), mutability can cause &ldquo;data races&rdquo;—unpredictable bugs from unsynchronized changes.</p>
<ul>
<li><strong>Safe concurrent writes:</strong> You can update different positions in a pre-allocated slice from different goroutines without locks, as long as no one changes the slice&rsquo;s size or creates sub-views during the updates.</li>
<li><strong>Risks to avoid:</strong> Don&rsquo;t mix growth or sub-view creation with concurrent updates—these can cause crashes or wrong data. Use tools like the race detector to catch issues.</li>
</ul>
<p><strong>Analogy:</strong> Think of concurrent updates like multiple chefs chopping veggies on separate cutting boards (different positions). It&rsquo;s fine until someone rearranges the boards mid-chop.</p>
<h4 id="code-example-concurrent-updates-without-races">Code Example: Concurrent Updates Without Races</h4>
<div class="highlight"><pre tabindex="0" style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#008000;font-weight:bold">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000;font-weight:bold">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#ba2121">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ba2121">&#34;sync&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000;font-weight:bold">func</span> <span style="color:#00f">main</span>() {
</span></span><span style="display:flex;"><span>    s <span style="color:#666">:=</span> <span style="color:#008000">make</span>([]<span style="color:#b00040">int</span>, <span style="color:#666">5</span>) <span style="color:#408080;font-style:italic">// Pre-allocate to avoid growth
</span></span></span><span style="display:flex;"><span><span style="color:#408080;font-style:italic"></span>    <span style="color:#008000;font-weight:bold">var</span> wg sync.WaitGroup
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#008000;font-weight:bold">for</span> i <span style="color:#666">:=</span> <span style="color:#666">0</span>; i &lt; <span style="color:#666">5</span>; i<span style="color:#666">++</span> {
</span></span><span style="display:flex;"><span>        wg.<span style="color:#00f">Add</span>(<span style="color:#666">1</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#008000;font-weight:bold">go</span> <span style="color:#008000;font-weight:bold">func</span>(idx <span style="color:#b00040">int</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#008000;font-weight:bold">defer</span> wg.<span style="color:#00f">Done</span>()
</span></span><span style="display:flex;"><span>            s[idx] = idx <span style="color:#666">*</span> <span style="color:#666">10</span> <span style="color:#408080;font-style:italic">// Update own position safely
</span></span></span><span style="display:flex;"><span><span style="color:#408080;font-style:italic"></span>        }(i)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    wg.<span style="color:#00f">Wait</span>()
</span></span><span style="display:flex;"><span>    fmt.<span style="color:#00f">Println</span>(s) <span style="color:#408080;font-style:italic">// Output like [0 10 20 30 40] (order may vary but correct)
</span></span></span><span style="display:flex;"><span><span style="color:#408080;font-style:italic"></span>}
</span></span></code></pre></div><p>Run with <code>go run -race main.go</code> to check for races—none here because positions are separate and no size changes.</p>
<hr>
<h3 id="mutability-in-methods-and-functions">Mutability in Methods and Functions</h3>
<p>How you define methods affects whether changes stick to the original data.</p>
<ul>
<li><strong>Array methods:</strong> Use a pointer receiver (like <code>func (a *[N]T) Method()</code>) to make changes visible outside the method, since non-pointer receivers work on copies.</li>
<li><strong>Slice methods:</strong> Non-pointer receivers can still update elements (shared storage), but return the slice if you change its size to update the caller&rsquo;s view.</li>
</ul>
<p>This is key for designing types that wrap arrays or slices, ensuring changes behave as expected.</p>
<hr>
<h3 id="interview-question-and-answer">Interview Question and Answer</h3>
<p><strong>Interview Question:</strong> &ldquo;How do you prevent a sub-slice from mutating the parent&rsquo;s data during append?&rdquo;</p>
<p><strong>Answer:</strong> &ldquo;Use the full slice expression like <code>parent[low:high:max]</code> to limit capacity, forcing append to allocate new storage. Or clone the sub-slice with <code>slices.Clone</code> for full independence.&rdquo;</p>
<p>This note adds practical ways to manage mutability without repeating basics, helping you build reliable code in teams or high-performance systems. For 7+ years engineers: Remember, mutability control is about ownership—decide early if data should be shared or copied to avoid debugging nightmares in production.</p>

  
  
    <div>
      <strong>Tags: </strong>
      
        
        
        
      
      &lt;a href=&#34;https://programmercave.com/tags/Go/&#34;&gt;Go&lt;/a&gt;
    </div>
  

    <footer class="site-footer">
  <span class="site-footer-credits">
  <h3>Promotions:</h3>
    <p><b><a href="https://atmanamviddhi.in/" target="_blank">Atmanam Viddhi</a>:</b> Visit <a href="https://atmanamviddhi.in/" target="_blank">Atmanam Viddhi</a> to embark on a journey of self-discovery and appreciation. This platform offers daily wisdom from timeless philosophical texts, guiding you to cultivate gratitude and affirm your divine nature. By writing down your gratitude and affirmations, you'll connect with your inner self and unlock a path to profound personal growth and spiritual awakening. Join the community today and start transforming your life with the power of reflection and affirmation!</p>  

    <p><b><a href="https://lovable.dev/?via=programmercave" target="_blank">Lovable</a>:</b> Tired of coding? <a href="https://lovable.dev/?via=programmercave" target="_blank">Lovable</a> is your AI-powered full-stack engineer! Go from idea to fully functional app in minutes. Perfect for founders, designers, and product teams. Try it now!</p>

    <p><b><a href="https://bytebytego.com?fpr=programmercave" target="_blank">ByteByteGo</a>:</b> Master system design with <a href="https://bytebytego.com?fpr=programmercave" target="_blank">ByteByteGo</a>, the ultimate resource for cracking interviews and building scalable systems! Their comprehensive courses simplify complex concepts using visual aids, real-world examples, and structured lessons, making learning engaging and effective. Whether you're a beginner or an experienced engineer, <a href="https://bytebytego.com?fpr=programmercave" target="_blank">ByteByteGo</a> equips you with the skills top tech companies demand. Gain in-depth knowledge of distributed systems, microservices, and high-level architecture to excel in your career. Don't just prepare—ace your system design interviews with confidence! 🚀 Start learning today and take your skills to the next level</p>

    <p><b><a href="https://namastedev.com?_aff=1738041847176" target="_blank">NamasteDev</a>:</b> Unlock your coding potential with <a href="https://namastedev.com?_aff=1738041847176" target="_blank">NamasteDev</a>, the ultimate EdTech platform for aspiring developers! Whether you're a beginner or looking to advance, <a href="https://namastedev.com?_aff=1738041847176" target="_blank">NamasteDev</a> offers top-tier courses like Namaste React, Namaste Node.js, and Frontend System Design—all designed for self-paced, project-based learning. Learn from industry experts, build real-world projects, and stay ahead with the latest tech trends. Join a thriving community of learners and take your skills to the next level. Start your journey today and open the door to endless career opportunities. Level up with NamasteDev—where learning meets innovation! 🚀🔥</p>

    <p><b><a href="https://www.scaler.com?unlock_code=MAIL575E" target="_blank">Scaler Academy</a>:</b> Elevate your tech career with <a href="https://www.scaler.com?unlock_code=MAIL575E" target="_blank">Scaler</a>! Join a community dedicated to transforming careers in technology. With over 15,000 successful career transitions and partnerships with 900+ placement partners, <a href="https://www.scaler.com?unlock_code=MAIL575E" target="_blank">Scaler</a> offers tailored learning experiences that can help you become part of the top 1% in the tech industry. <br>
    Explore a variety of programs, participate in live classes, and gain access to valuable resources designed to enhance your skills. Whether you're looking to advance in your current role or pivot to a new career, <a href="https://www.scaler.com?unlock_code=MAIL575E" target="_blank">Scaler</a> provides the support and guidance you need to succeed. Don't miss out—book your free live class today!</p> 
    
    <a href="https://programmercave.com/" class="fa fa-home"></a>

    <a href="https://www.facebook.com/programmercave" class="fab fa-facebook"></a>

    <a href="https://github.com/abhiabhi0" class="fab fa-github"></a>

    <a href="https://twitter.com/programmercave" class="fab fa-twitter"></a>

    <a href="https://medium.com/@programmercave0" class="fab fa-medium"></a>

    <a href="https://www.instagram.com/programmercave" class="fab fa-instagram"></a>

    <a href="https://t.me/programmercave" class="fab fa-telegram"></a>

    <a href="https://www.youtube.com/channel/UCGpGM7FBgVm7Cmuo6OrUYGQ" class="fab fa-youtube"></a>

    <p>Copyright © 2025 programmerCave</p>  </span>
</footer>

  </section>
  
  
  <script>
  window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
  ga('create', 'G-LGYYYX4F59', 'auto');
  ga('send', 'pageview');
  </script>
  <script async src='https://www.google-analytics.com/analytics.js'></script>
  


  <script type="text/javascript">
    var infolinks_pid = 3210490;
    var infolinks_wsid = 0;
    </script>
    <script type="text/javascript" src="http://resources.infolinks.com/js/infolinks_main.js"></script>
</body>
</html>
